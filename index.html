<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Traffic Simulation Logger</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --box:#f9f9f9; --line:#ddd; --muted:#555; --ok:#0a7; --err:#b00;
    }
    body { font-family: Arial, sans-serif; margin: 0; }
    h1 { margin: 12px; }
    iframe { border: 1px solid #ccc; width: 100%; height: 640px; }
    #controls {
      margin: 10px 12px; padding: 10px; background: var(--box);
      border: 1px solid var(--line); display: grid; gap: 8px;
      grid-template-columns: 1fr auto auto; align-items: center;
    }
    .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    button { margin: 0; padding: 10px 14px; cursor: pointer; }
    select, input[type="text"] { padding: 8px; }
    #output { white-space: pre-line; margin: 10px 12px; }
    .muted { color: var(--muted); }
    .ok { color: var(--ok); }
    .err { color: var(--err); }
    .logline { margin: 0.2em 0; }
    .links a { display:block; }
    .tiny { font-size: 12px; }
    .spacer { flex: 1 1 auto; }
  </style>
</head>
<body>
  <h1>Traffic Simulation Logger</h1>

  <!-- NetLogo Web model in an iframe (swap this SRC later for HubNet Web teacher) -->
  <iframe id="nlw"
    src="https://www.netlogoweb.org/launch#https://shir8may.github.io/traffic-sim-logger/traffic-sim.nlogo"
    referrerpolicy="no-referrer"
  ></iframe>

  <div id="controls">
    <div class="row">
      <label class="muted">Mode:</label>
      <select id="mode">
        <option value="drive" selected>Upload to Drive (Apps Script)</option>
        <option value="local">Download locally</option>
      </select>
      <span class="tiny muted">After a successful <b>Run</b> upload, the model buffer will be cleared.</span>
    </div>

    <div class="row">
      <button id="btn-init">Download Init CSV</button>
      <button id="btn-run">Download Run CSV</button>
    </div>

    <div class="row">
      <label class="muted" for="filebase">File base:</label>
      <input id="filebase" type="text" value="logger" size="14" />
      <span class="spacer"></span>
      <label class="tiny muted"><input id="debug" type="checkbox" /> Debug</label>
    </div>
  </div>

  <div id="output" class="muted">Wrapper page loaded. Waiting for the modelâ€¦</div>

  <script>
  /***********************
   * ðŸ”§ SET THESE IF NEEDED
   ***********************/
  const APPS_SCRIPT_URL =
    "https://script.google.com/macros/s/AKfycby8icKZjsdXeHmxIprEKsfjPq3rcWcVvDRt8Vib41DB1EbqBt5FpGqkeuSA5PGQvIZ9/exec";

  // Origins we accept messages from (in addition to the iframe window itself).
  const ALLOWED_ORIGINS = new Set([
    "https://www.netlogoweb.org",
    "https://netlogoweb.org",
    "https://shir8may.github.io",
    window.location.origin, // allow same-origin bubble-backs
    // "http://localhost:8080", // <- uncomment for local dev if needed
    // "http://127.0.0.1:8080",
  ]);

  /******************************************************************
   * Small DOM helpers
   ******************************************************************/
  const elMode = document.getElementById("mode");
  const elOut  = document.getElementById("output");
  const elBase = document.getElementById("filebase");
  const elDbg  = document.getElementById("debug");
  const nlwFrame = document.getElementById("nlw");

  function ts() {
    const d = new Date();
    const pad = (n)=> String(n).padStart(2,"0");
    return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  }
  function clearOutput() { elOut.textContent = ""; }
  function log(msg, css="muted") {
    const div = document.createElement("div");
    div.className = `logline ${css}`;
    div.textContent = msg;
    elOut.appendChild(div);
  }
  function logLinks(title, openUrl, dlUrl) {
    const wrapper = document.createElement("div");
    wrapper.className = "links ok";
    wrapper.innerHTML = `<div>${title}</div>
      <a target="_blank" rel="noopener" href="${openUrl}">File (open)</a>
      <a target="_blank" rel="noopener" href="${dlUrl}">File (download)</a>`;
    elOut.appendChild(wrapper);
  }

  function downloadCSVLocally(filename, text) {
    const blob = new Blob([text], { type: "text/csv" });
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(url);
    a.remove();
  }

  async function uploadCSVToDrive(filename, csvText) {
    const url = `${APPS_SCRIPT_URL}?filename=${encodeURIComponent(filename)}`;
    const resp = await fetch(url, {
      method: "POST",
      mode: "cors",
      headers: { "Content-Type": "text/csv" },
      body: csvText
    });
    const text = await resp.text();
    if (!resp.ok) throw new Error(`Apps Script error: ${resp.status} ${text}`);

    // Try to parse the two link lines; otherwise just show the raw response.
    const openMatch = text.match(/File \(open\):\s*(\S+)/i);
    const dlMatch   = text.match(/File \(download\):\s*(\S+)/i);
    return { raw:text, openUrl: openMatch?.[1] || null, dlUrl: dlMatch?.[1] || null };
  }

  /******************************************************************
   * Robust NetLogo Web bridge (multi-shape replies + idless fallback)
   ******************************************************************/
  let req = 0;
  const pending = new Map();

  function isFromIframeSource(event) {
    try { return event.source === nlwFrame.contentWindow; }
    catch { return false; }
  }

  function isTrustedEvent(event) {
    // Accept if it's literally from the iframe contentWindow OR origin is in our allowlist.
    if (isFromIframeSource(event)) return true;
    if (ALLOWED_ORIGINS.has(event.origin)) return true;
    return false;
  }

  function dbgLog(direction, payload, extra = {}) {
    if (!elDbg.checked) return;
    const tag = direction === "SEND" ? "SEND >>>" : "EVT <<<";
    console.log(tag, payload, extra);
  }

  // Normalize a reply into {id, ok, value, error}
  function normalizeReply(data) {
    if (typeof data !== "object" || data === null) return null;

    const id = data.requestId ?? data.id ?? null;
    const ok =
      data.nlw === "ok" ||
      data.type === "nlw:ok" ||
      data.type === "NLW_OK" ||
      data.ok === true ||
      false;

    let value = undefined;
    if ("result" in data) value = data.result;
    else if ("value" in data) value = data.value;

    const error = data.error || data.message || null;

    // Heuristic: some builds wrap as {type:"...", payload:{...}}
    if (!ok && !error && data.payload && typeof data.payload === "object") {
      const inner = normalizeReply(data.payload);
      if (inner) return inner;
    }

    return { id, ok, value, error };
  }

  window.addEventListener("message", (event) => {
    // Filter obvious noise first: must be trusted or from iframe
    if (!isTrustedEvent(event)) return;

    // Optional debug (kept clean)
    dbgLog("EVT", event.data, { origin:event.origin, sameSource:isFromIframeSource(event) });

    const norm = normalizeReply(event.data);
    if (!norm) return; // ignore unrelated shapes

    const { id, ok, value, error } = norm;

    // A) Normal: match by id
    if (id && pending.has(id)) {
      const { resolve, reject, t } = pending.get(id);
      clearTimeout(t); pending.delete(id);
      return ok ? resolve(value) : reject(new Error(error || "Unknown reply"));
    }

    // B) Idless but looks OK â†’ resolve the oldest pending (fallback)
    if (!id && ok && (value !== undefined) && pending.size > 0) {
      const oldestId = pending.keys().next().value;
      const { resolve, t } = pending.get(oldestId);
      clearTimeout(t); pending.delete(oldestId);
      console.warn("EVT <<< FALLBACK matched (no id) -> resolving", oldestId);
      return resolve(value);
    }

    // Otherwise ignore (could be a broadcast or unrelated extension message)
  }, false);

  // Send a burst of equivalent requests; resolve on the first good reply.
  function talk(payloads, timeoutMs = 25000) {
    return new Promise((resolve, reject) => {
      const id = "r" + (++req);
      const t = setTimeout(() => {
        pending.delete(id);
        reject(new Error("Timed out waiting for NetLogo Web response."));
      }, timeoutMs);
      pending.set(id, { resolve, reject, t });

      const send = (msg) => {
        const outgoing = { ...msg, id, requestId: id };
        dbgLog("SEND", outgoing);
        // Using "*" because NLW frame is cross-origin; we gate on receive.
        nlwFrame.contentWindow.postMessage(outgoing, "*");
      };
      payloads.forEach(send);
    });
  }

  // Auto-wrap a bare reporter name to a valid NetLogo expression.
  function wrapReporter(expr) {
    const s = String(expr).trim();
    if (!s) return "()";
    if (s.startsWith("(") && s.endsWith(")")) return s;
    // If it already looks like an expression (space or special chars), keep it.
    if (/[ \t\n\r"'`]/.test(s)) return s;
    // Otherwise wrap bare symbol â†’ (symbol)
    return `(${s})`;
  }

  async function nlwRunReporter(expr) {
    const code = wrapReporter(expr);
    return talk([
      { action: "runresult", agent: "observer", code },
      { type: "nlw:runresult", agent: "observer", code },
      { type: "NLW_RUNRESULT", agent: "observer", code },
      // some older variants omit 'agent'
      { action: "runresult", code },
      { type: "nlw:runresult", code }
    ]);
  }
  async function nlwRunCommand(code) {
    return talk([
      { action: "run", agent: "observer", code },
      { type: "nlw:run", agent: "observer", code },
      { type: "NLW_RUN", agent: "observer", code },
      { action: "run", code },
      { type: "nlw:run", code }
    ]);
  }

  // Friendly load note
  nlwFrame.addEventListener("load", () => {
    clearOutput();
    log("Model iframe loaded. You can use the buttons now.", "ok");
  });

  /******************************************************************
   * CSV workflow
   ******************************************************************/
  async function handleCSV(kind) {
    clearOutput();
    log(`Requesting ${kind.toUpperCase()} CSV from modelâ€¦`);
    try {
      const reporter = (kind === "init") ? "csv-init-text" : "csv-run-text";
      const csv = await nlwRunReporter(reporter);

      if (!csv || !String(csv).trim()) {
        log(`The ${kind} CSV is empty â€” nothing to ${elMode.value === "drive" ? "upload" : "download"}.`, "err");
        return;
      }

      const base = (elBase.value || "logger").trim();
      const name = (kind === "init")
        ? `${base}_world_init_data_${ts()}.csv`
        : `${base}_run_${ts()}.csv`;

      if (elMode.value === "drive") {
        log("Uploading to Google Drive (Apps Script)â€¦");
        const { openUrl, dlUrl, raw } = await uploadCSVToDrive(name, csv);
        log(`SAVED: ${name}`, "ok");
        if (openUrl || dlUrl) {
          logLinks("Links returned by Apps Script:", openUrl || "#", dlUrl || "#");
        } else {
          log(raw, "muted");
        }
      } else {
        downloadCSVLocally(name, csv);
        log(`Downloaded ${name} locally.`, "ok");
      }

      if (kind === "run") {
        log("Clearing run buffer in the modelâ€¦");
        await nlwRunCommand("clear-csv-run");
        log("Run buffer cleared.", "ok");
      }
    } catch (e) {
      log(`Error: ${e.message}`, "err");
    }
  }

  // Wire buttons
  document.getElementById("btn-init").addEventListener("click", () => handleCSV("init"));
  document.getElementById("btn-run").addEventListener("click", () => handleCSV("run"));
  </script>
</body>
</html>
